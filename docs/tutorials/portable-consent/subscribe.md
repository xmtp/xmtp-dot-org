---
sidebar_label: Subscribe
sidebar_position: 4
---

# Enabling Subscribers with XMTP

![Feature status](https://img.shields.io/badge/Feature_status-Alpha-orange)

:::caution This feature is inÂ **alpha**Â status

This feature is inÂ **alpha**Â status and ready for you to start experimenting with. However, we doÂ notÂ recommend using alpha features in production apps. Expect frequent changes as we iterate based on feedback. Want to provide feedback? Comment on [Proposal: Portable consent state for v2 SDKs](https://github.com/orgs/xmtp/discussions/49).

:::

<div class=" rabbit  p-5 ">

ðŸ“¥ <b>Need a Quick Reference?</b> Check out the GitHub repo: <a href="https://github.com/fabriguespe/xmtp-subscribe-portable-consent">xmtp-subscribe</a>.

</div>

This tutorial will guide you on how to create a simple `Subscribe` button with consent that enables the user to subscribe to your messages or notifications.

#### Import libraries

Import the necessary XMTP and Ethereum packages. These libraries enable you to create an XMTP client and interact with the Ethereum blockchain.

```jsx
import React, { useEffect, useState } from "react";
import { Client } from "@xmtp/xmtp-js";
import { ethers } from "ethers";
```

The receiver of the subscription (you), in this case is gong to be a random wallet generated by `ethers`, but you could send your own wallet as prop. This wallet is later going to

#### Subscribe with your Wallet

Your `connectWallet` function facilitates the connection to the user's Ethereum wallet.

```jsx
let wallet = await connectWallet();
let client = await Client.create(wallet, { env: env });
```

##### Consent State Management

This section delves into a crucial part of the subscription widget â€” managing the consent state of a subscriber. We'll explore how to get the subscriber's address, refresh the consent list, get the current consent state, and then update it based on user actions.

#### Refresh the Consent List

To ensure we're working with the most up-to-date information, we refresh the consent list.

```jsx
// Refresh content list
await client.contacts.refreshConsentList();
```

#### Retrieve the Current Consent State

After refreshing, we get the current consent state of the subscriber. Can be (`allowed`, `blocked`, or `unknown`)

```jsx
// Get the consent state of the subscriber
let state = client.contacts.consentState(client.address);
```

#### Update the Consent State

Based on the current state, we either allow or block the subscriber.

```jsx
// If the state is unknown or blocked, allow the subscriber
if (state == "unknown" || state == "denied") {
  await client.contacts.allow([client.address]);
}
```

- If the state is `unknown` or `blocked`, we change it to `allowed` using `client.contacts.allow([address])` and we call the `onSubscribe` function if it exists.
- If the state is `allowed`, we don't change the consent and we call the `onUnsubscribe` function if it exists.

**Callbacks**

The `onSubscribe` and `onUnsubscribe` functions are called when the consent state is updated. You can use these functions to update your local state or to send a message to your subscribers.

```jsx
<Subscribe
  onSubscribe={(address) => {
    //Update local db
    //or send a message to the subscriber
  }}
  onUnsubscribe={(address) => {
    //Update local db
    //or send a message to the subscriber
  }}
/>
```

#### Reference code

Copy paste the component into your project

```jsx
import React, { useEffect, useState } from "react";
import { Client } from "@xmtp/xmtp-js";
import { ethers } from "ethers";

export function Subscribe({
  senderAddress,
  onSubscribe,
  onUnsubscribe,
  onError,
  env,
  label = "Subscribe with your wallet",
}) {
  // State for loading status
  const [loading, setLoading] = useState(false);
  // State for subscription status
  const [subscriptionStatus, setSubscriptionStatus] = useState(label);
  // State for consent log
  const [consentLog, setConsentLog] = useState("");
  // State for sender address

  const styles = {
    SubscribeButtonContainer: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      borderRadius: "5px",
      textAlign: "center",
      alignItems: "center",
    },
    SubscribeButton: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      padding: "10px 20px",
      borderRadius: "5px",
      marginBottom: "2px",
      textAlign: "left",
      cursor: "pointer",
      transition: "background-color 0.3s ease",
      fontWeight: "bold",
      color: "#333333",
      backgroundColor: "#ededed",
      border: "none",
      fontSize: "12px",
    },
  };

  const connectWallet = async () => {
    if (typeof window.ethereum !== "undefined") {
      try {
        await window.ethereum.request({ method: "eth_requestAccounts" });
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        return provider.getSigner();
      } catch (error) {
        console.error("User rejected request", error);
      }
    } else {
      console.error("Metamask not found");
    }
  };

  // Define the handleClick function
  const handleClick = async () => {
    try {
      // Set loading to true
      setLoading(true);
      // Get the subscriber
      let wallet = await connectWallet();
      let client = await Client.create(wallet, { env: env });
      // Refresh content list
      await client.contacts.refreshConsentList();
      // Get the consent state of the subscriber
      let state = client.contacts.consentState(client.address);
      // If the state is unknown or blocked, allow the subscriber
      if (state == "unknown" || state == "denied") {
        await client.contacts.allow([client.address]);
        if (typeof onSubscribe === "function") onSubscribe(client.address);
      } else if (state == "allowed") {
        // If the state is allowed, block the subscriber
        if (typeof onUnsubscribe === "function") onUnsubscribe(client.address);
      }
      // Create a log message
      let log =
        "Address " +
        client.address +
        " subscribed to random wallet: " +
        addressToAllow;
      setConsentLog(log);
      console.log(log);

      // Set the subscription label
      setSubscriptionStatus("Consent State: " + state);

      // Set loading to false
      setLoading(false);
    } catch (error) {
      // If onError function exists, call it with the error
      if (typeof onError === "function") onError(error);
      // Log the error
      console.log(error);
    }
  };

  return (
    <div
      style={styles.SubscribeButtonContainer}
      className={`Subscribe ${loading ? "loading" : ""}`}>
      <small>Sender address: {senderAddress}</small>
      <button style={styles.SubscribeButton} onClick={handleClick}>
        {loading ? "Loading... " : subscriptionStatus}
      </button>
    </div>
  );
}
```

#### Example repo

- _You can find a complete example of this tutorial in our [xmtp-subscribe-portable-consent](https://github.com/fabriguespe/xmtp-subscribe-portable-consent)_
